"""Various methods used to visualize the data generated by PicModel."""
import datetime
import math
import os
from functools import partial

from matplotlib import pyplot as plt
from matplotlib.animation import FuncAnimation
import numpy as np

from model import PicModel
from util import save_plot, create_folder
from weighting import weight_particles


plt.style.use("dark_background")


def _plot_energy_ax(m: PicModel, ax_energy):
    c = m.c
    d = m.d
    t_max = c.t_max
    ke_hist = d.ke_hist
    fe_hist = d.fe_hist
    time_axis = c.time_axis
    ax_energy.set_title("Energy")
    ax_energy.set_xlim(0, t_max)
    ax_energy.set_ylabel("energy")
    ax_energy.set_xlabel("time")
    ax_energy.set_yscale("log")
    (pt_te,) = ax_energy.plot(
        time_axis, ke_hist + fe_hist, "r-", markersize=1, label="total"
    )
    (pt_ke,) = ax_energy.plot(
        time_axis, ke_hist, "b-", markersize=1, label="ke"
    )
    (pt_fe,) = ax_energy.plot(
        time_axis, fe_hist, "g-", markersize=1, label="fe"
    )
    ax_energy.legend(
        [pt_ke, pt_fe, pt_te],
        [pt_ke.get_label(), pt_fe.get_label(), pt_te.get_label()],
        loc="lower right",
    )
    return ax_energy


def plot_energy_history(
    m: PicModel, plot_title="Time evolution of energy", hold=True
):
    """Generate log-log plot of the total kinetic and field energy history."""
    print("Generating plots of the total energy history.")
    fig = plt.figure(figsize=(12, 6))
    fig.suptitle(plot_title)
    ax_energy = fig.add_subplot(2, 1, (1, 2))
    _plot_energy_ax(m, ax_energy)
    plt.tight_layout()
    now_seconds = (
        datetime.datetime.now()
        - datetime.datetime.now().replace(
            hour=0, minute=0, second=0, microsecond=0
        )
    ).total_seconds()
    save_plot(
        f"energy_instability_growth_{datetime.datetime.now().strftime('%Y-%m-%d_') + str(now_seconds)}.pdf"
    )
    if hold:
        plt.show()  # Waits for user to close the plots
    else:
        return ax_energy


def plot_initial_distribution(m: PicModel, hold=True):
    """Plot initial particle configuration using pyplot."""
    c = m.c
    print("Generating plots of initial particle state.")
    bin_width = 0.01

    fig1 = plt.figure(figsize=(12, 8))
    fig1.suptitle(f"Initial distribution (n={c.N})")
    # Get the un-normalized and normalized particle positions and velocities
    x_i_unorm = c.initial_x
    x_i = (x_i_unorm - c.x_min) / c.L
    vx_i_unorm = c.initial_vx
    x_j = c.x_j
    x_j_unorm = (c.x_j * c.L) + c.x_min

    # Plot initial weighted particle positions on the grid
    rho_weight_ngp = weight_particles(np.sort(x_i), x_j, c.dx, c.M, order=0)
    print(f"Total charge (ngp): {np.sum(rho_weight_ngp * c.dx)}")
    rho_weight_lin = weight_particles(np.sort(x_i), x_j, c.dx, c.M, order=1)
    print(f"Total charge (linear): {np.sum(rho_weight_lin * c.dx)}")
    ax_init_position = fig1.add_subplot(2, 2, 1)
    (pt_ngp,) = ax_init_position.step(
        np.sort(x_j_unorm),
        rho_weight_ngp,
        color="r",
        marker="o",
        where="mid",
        linewidth=1,
        label="NGP",
        markersize=1,
    )
    (pt_linear,) = ax_init_position.plot(
        np.sort(x_j_unorm),
        rho_weight_lin,
        color="g",
        marker="o",
        linestyle="--",
        linewidth=2,
        label="Linear",
        markersize=1,
    )
    ax_init_position.legend(
        [pt_ngp, pt_linear],
        [pt_ngp.get_label(), pt_linear.get_label()],
    )
    ax_init_position.set_ylim(bottom=0)
    ax_init_position.set_xlabel(r"$x$")
    ax_init_position.set_ylabel("Density")
    plt.xlim(c.x_range)
    plt.title("Position")

    # Plot initial velocity histogram
    ax_init_velocity = fig1.add_subplot(2, 2, 2)
    bins = math.ceil((c.vx_range[1] - c.vx_range[0]) / bin_width)
    ax_init_velocity.hist(vx_i_unorm, bins=bins, range=c.vx_range)
    ax_init_velocity.set_xlabel(r"$v$")
    plt.xlim(c.x_range)
    plt.title("Velocity")

    # Plot initial positions in phase space
    ax_init_phase = fig1.add_subplot(2, 2, (3, 4))
    plt.title("Initial phase space")
    n2 = math.ceil(c.N / 2)
    ax_init_phase.plot(
        x_i_unorm[:n2],
        vx_i_unorm[:n2],
        ".",
        color="tab:orange",
        markersize=c.markersize,
        label="xv",
    )
    ax_init_phase.plot(
        x_i_unorm[n2:],
        vx_i_unorm[n2:],
        ".",
        color="tab:cyan",
        markersize=c.markersize,
        label="xv",
    )
    plt.xlim(c.x_range)
    ax_init_phase.set_xlabel(r"$x$")
    ax_init_phase.set_ylabel(r"$v$")
    # Plot grid points
    if c.plot_grid_lines:
        for grid_pt in x_j_unorm:
            ax_init_phase.axvline(
                grid_pt,
                linestyle="--",
                color="k",
                linewidth=0.2,
            )
            ax_init_position.axvline(
                grid_pt,
                linestyle="--",
                color="k",
                linewidth=0.2,
            )
    plt.tight_layout()
    save_plot(f"initial_hist_{c.N}_particles.pdf")
    if hold:
        plt.show()  # Waits for user to close the plot


def plot_snapshots_velocity(
    m: PicModel,
    snapshot_times: list = [],
    hold: bool = True,
    plot_title: str = "Time snapshots",
):
    print("Generating snapshots of f(v) at various time intervals.")
    c = m.c
    d = m.d
    if not m.has_run:
        m.run()
    t_max = c.t_max
    if not snapshot_times:
        snapshot_times = [0, 0.25 * t_max, 0.5 * t_max, 0.75 * t_max, t_max]
    dt = c.dt
    t_steps = c.t_steps
    N = c.N
    L = c.L
    subsample_ratio = c.subsample_ratio
    x_hist = d.x_hist
    v_hist = d.vx_hist
    snapshot_times.sort()
    snapshot_frames = [math.floor(t / dt) for t in snapshot_times]
    snapshots = []
    for frame in range(t_steps):
        if frame in snapshot_frames:
            snapshots.append(
                {
                    "x": x_hist[:, int(frame / subsample_ratio)],
                    "v": v_hist[:, int(frame / subsample_ratio)],
                    "frame": frame,
                }
            )
    print(f"Sampled {len(snapshots)} snapshots over {t_steps} time steps.")
    fig = plt.figure(figsize=(6, 8))
    fig.suptitle(plot_title)
    ax_fv = fig.add_subplot(111)
    ax_fv.set_ylabel(r"$N f(v)$")
    ax_fv.set_xlabel("v")
    ax_fv.set_xlim(np.max(d.vx_hist * L), np.min(d.vx_hist * L))
    for snapshot in snapshots:
        cur_t = snapshot["frame"] * dt
        ax_fv.hist(
            snapshot["v"] * L,
            bins=64,
            fill=False,
            # color="tab:orange",
            histtype="step",
            label=f"$t={cur_t:.2f}$",
        )
    ax_fv.legend()
    plt.yscale("log")
    plt.tight_layout()
    save_plot(f"fv_hist_{N}_particles.pdf")
    if hold:
        plt.show()  # Waits for user to close the plots


def plot_snapshots(
    m: PicModel,
    snapshot_times: list = [],
    hold: bool = True,
    plot_title: str = "Time snapshots",
    filename: str = "snapshots.pdf",
):
    print("Generating snapshots of state at various time intervals.")
    c = m.c
    d = m.d
    if not m.has_run:
        m.run()
    t_max = c.t_max
    if not snapshot_times:
        snapshot_times = [0, 0.25 * t_max, 0.5 * t_max, 0.75 * t_max, t_max]
    dt = c.dt
    t_steps = c.t_steps
    N = c.N
    L = c.L
    x_min = c.x_min
    x_range = c.x_range
    subsample_ratio = c.subsample_ratio
    x_hist = d.x_hist
    v_hist = d.vx_hist
    snapshot_times.sort()
    snapshot_frames = [math.floor(t / dt) for t in snapshot_times]
    snapshots = []
    for frame in range(t_steps):
        if frame in snapshot_frames:
            snapshots.append(
                {
                    "x": x_hist[:, int(frame / subsample_ratio)],
                    "v": v_hist[:, int(frame / subsample_ratio)],
                    "frame": frame,
                }
            )
    print(f"Sampled {len(snapshots)} snapshots over {t_steps} time steps.")
    fig = plt.figure(figsize=(6, 8))
    fig.suptitle(plot_title)
    num_subplots = len(snapshots)
    idx = 1
    n2 = math.ceil(c.N / 2)
    for snapshot in snapshots:
        ax_xv = fig.add_subplot(num_subplots, 1, idx)
        cur_t = snapshot["frame"] * dt
        ax_xv.set_ylabel("v")
        ax_xv.set_title(f"t={cur_t:.2f}")
        plt.plot(
            (snapshot["x"][:n2] * L) + x_min,
            (snapshot["v"][:n2] * L),
            ".",
            color="tab:orange",
            markersize=1,
        )
        plt.plot(
            (snapshot["x"][n2:] * L) + x_min,
            (snapshot["v"][n2:] * L),
            ".",
            color="tab:cyan",
            markersize=1,
        )

        plt.xlim(x_range)
        if idx == num_subplots:
            ax_xv.set_xlabel("x")
        idx += 1
    plt.tight_layout()
    save_plot(filename)
    if hold:
        plt.show()  # Waits for user to close the plots


def plot_traces(
    m: PicModel,
    max_traces: int = 30,
    hold: bool = True,
    plot_title: str = "Particle traces",
    start_at_frame: int = 0,
):
    """Generate trace plots of particles in phase space.

    Args:
        m: Initialized PicModel
        max_traces: Plot traces of up to this many particles.
        hold: If True, hold plots with plt.show()
        start_at_frame: Plot traces starting a this timestep.
    """
    c = m.c
    d = m.d
    if not m.has_run:
        m.run()
    N = c.N
    x_hist = d.x_hist
    v_hist = d.vx_hist
    x_range = c.x_range
    L = c.L
    x_min = c.x_min
    fig = plt.figure(figsize=(12, 8))
    ax_xv = fig.add_subplot(211)
    for i in range(N)[:: int(N / max_traces)]:
        position = (x_hist[i, start_at_frame:] * L) + x_min
        velocity = v_hist[i, start_at_frame:] * L
        ax_xv.plot(position, velocity, ".", markersize=1)
        ax_xv.set_xlabel("x")
        ax_xv.set_ylabel("v")
        ax_xv.set_title(plot_title)
        ax_xv.set_xlim(x_range)
    ax_energy = fig.add_subplot(212)
    _plot_energy_ax(m, ax_energy)
    plt.tight_layout()
    save_plot(f"traces_{N}_particles.pdf")
    if hold:
        plt.show()  # Waits for user to close the plots
    return ax_energy


def _init_animation(
    # x_range, v_min, v_max, ax_xv, pt_xv1, pt_xv2, pt_ke, pt_fe, pt_te
    x_range,
    v_min,
    v_max,
    ax_xv,
    pt_xv1,
    pt_xv2,
    pt_efield,
):
    # ax_xv.set_xlim(x_range)
    # ax_xv.set_ylim(v_min, v_max)
    # return (pt_xv1, pt_xv2, pt_ke, pt_fe, pt_te)
    return (pt_xv1, pt_xv2, pt_efield)


def _animate_frame(
    frame,
    x_hist,
    v_hist,
    efield_hist,
    x_j,
    # ke_hist,
    # fe_hist,
    x_min,
    L,
    # time_axis,
    # pt_ke,
    # pt_fe,
    # pt_te,
    # ax_efield,
    pt_xv1,
    pt_xv2,
    pt_efield,
    time_text,
    vline_t,
    subsample_ratio,
    dt,
):
    current_time = frame * dt * subsample_ratio
    time_text.set_text(f"t = {current_time:.2f}")
    vline_t.set_xdata([current_time, current_time])
    N = x_hist.shape[0]
    n2 = math.ceil(N / 2)
    pt_xv1.set_data((x_hist[:n2, frame] * L) + x_min, (v_hist[:n2, frame] * L))
    if n2 > 0:
        pt_xv2.set_data(
            (x_hist[n2:, frame] * L) + x_min, (v_hist[n2:, frame] * L)
        )
    # ax_efield.set_ylim(
    #     np.min(efield_hist[:, frame]), np.max(efield_hist[:, frame])
    # )
    pt_efield.set_data((x_j * L) + x_min, efield_hist[:, frame])
    # pt_ke.set_data(time_axis, ke_hist)
    # pt_fe.set_data(time_axis, fe_hist)
    # pt_te.set_data(time_axis, fe_hist + ke_hist)
    # return (pt_xv1, pt_xv2, time_text, pt_ke, pt_fe, pt_te)
    return (pt_xv1, pt_xv2, time_text, vline_t, pt_efield)


def animate_phase_space(
    m: PicModel,
    plot_title="Phase space animation",
    repeat: bool = False,
    hold: bool = True,
):
    """Generate an animation of the particles in phase space over time.

    The positions of all particles in phase space are plotted alongside the
    history of the total energy, the field potential energy, and the total
    kinetic energy.

    Important Note: Using hold=False will save a .mp4 of the animation to disk,
    but requires ffmpeg to be installed and accessible on the PATH.
    """
    if not m.has_run:
        m.run()
    c = m.c
    d = m.d
    # t_max = c.t_max
    dt = c.dt
    x_range = c.x_range
    markersize = c.markersize

    fig = plt.figure(figsize=(12, 8))
    fig.suptitle(plot_title)
    ax_xv = plt.subplot2grid((2, 2), (0, 0), colspan=2, rowspan=1)
    ax_energy = plt.subplot2grid((2, 2), (1, 0), colspan=1, rowspan=1)
    ax_efield = plt.subplot2grid((2, 2), (1, 1), colspan=1, rowspan=1)

    ax_xv.set_title("Phase space animation")
    ax_xv.set_ylabel("v")
    ax_xv.set_xlabel("x")
    ax_xv.set_xlim(x_range)
    v_range = (np.min(d.vx_hist) * 1.2 * c.L, np.max(d.vx_hist) * 1.2 * c.L)
    ax_xv.set_ylim(v_range)

    _plot_energy_ax(m, ax_energy)
    vline_t = ax_energy.axvline(0, ls="--", color="darkgray", zorder=10)

    ax_efield.set_title("Electric field")
    ax_efield.set_ylabel(r"$E$")
    ax_efield.set_xlabel(r"$x$")
    ax_efield.set_xlim(x_range)
    ax_efield.set_ylim(np.min(d.ex_hist), np.max(d.ex_hist))

    (pt_xv1,) = ax_xv.plot(
        [],
        [],
        ".",
        color="tab:orange",
        markersize=markersize,
        label="xv",
    )
    (pt_xv2,) = ax_xv.plot(
        [],
        [],
        ".",
        color="tab:cyan",
        markersize=markersize,
        label="xv",
    )

    (pt_efield,) = ax_efield.plot([], [], "-", color="tab:green", label="E")
    # (pt_ke,) = ax_energy.plot(
    #     c.time_axis, d.ke_hist, "b-", markersize=1, label="ke"
    # )
    # (pt_fe,) = ax_energy.plot(
    #     c.time_axis, d.ke_hist, "g-", markersize=1, label="fe"
    # )
    # (pt_te,) = ax_energy.plot(
    #     c.time_axis, d.ke_hist, "k-", markersize=1, label="total"
    # )
    # ax_energy.legend(
    #     [pt_ke, pt_fe, pt_te],
    #     [pt_ke.get_label(), pt_fe.get_label(), pt_te.get_label()],
    # )

    # Add a label to the frame showing the current time. Updated each time step
    # in update()
    time_text = ax_xv.text(0.02, 0.95, "", transform=ax_xv.transAxes)
    animate = partial(
        _animate_frame,
        x_hist=d.x_hist,
        v_hist=d.vx_hist,
        efield_hist=d.ex_hist,
        # ke_hist=d.ke_hist,
        # fe_hist=d.fe_hist,
        x_j=c.x_j,
        x_min=c.x_min,
        L=c.L,
        # ax_efield=ax_efield,
        # time_axis=c.time_axis,
        # pt_ke=pt_ke,
        # pt_fe=pt_fe,
        # pt_te=pt_te,
        pt_xv1=pt_xv1,
        pt_xv2=pt_xv2,
        pt_efield=pt_efield,
        time_text=time_text,
        vline_t=vline_t,
        subsample_ratio=c.subsample_ratio,
        dt=dt,
    )
    init_animation = partial(
        _init_animation,
        x_range=c.x_range,
        v_min=c.vx_min,
        v_max=c.vx_max,
        ax_xv=ax_xv,
        pt_xv1=pt_xv1,
        pt_xv2=pt_xv2,
        pt_efield=pt_efield,
        # pt_ke=pt_ke,
        # pt_fe=pt_fe,
        # pt_te=pt_te,
    )
    # Evolve positions until t_max. Animate particle positions in phase space.
    animation = FuncAnimation(
        fig,
        animate,
        frames=range(d.x_hist.shape[1]),
        init_func=init_animation,
        blit=True,
        interval=4,
        repeat=repeat,
    )
    plt.tight_layout()
    if hold:
        plt.show()  # Waits for user to close the plot
    else:
        create_folder(os.path.join(os.getcwd(), "plots", "pic1"))
        now_seconds = (
            datetime.datetime.now()
            - datetime.datetime.now().replace(
                hour=0, minute=0, second=0, microsecond=0
            )
        ).total_seconds()
        animation_name = os.path.join(
            "plots",
            "pic1",
            f"animation_{datetime.datetime.now().strftime('%Y-%m-%d_') + str(now_seconds)}.mp4",
        )
        animation.save(
            animation_name,
            progress_callback=lambda i, n: print(f"Saving frame {i} of {n}"),
        )
        plt.close(fig)
        print(f"Saved animation {animation_name} to disk.")
