"""Various methods used to visualize the data generated by PicModel."""
import datetime
import math
import os
from functools import partial

from matplotlib import pyplot as plt
from matplotlib.animation import FuncAnimation
import numpy as np

from model import PicModel
from util import save_plot, create_folder
from weighting import weight_particles


def _plot_energy_ax(m: PicModel, ax_energy):
    c = m.c
    d = m.d
    t_max = c.t_max
    ke_hist = d.ke_hist
    fe_hist = d.fe_hist
    time_axis = c.time_axis
    ax_energy.set_title("Energy")
    ax_energy.set_xlim(0, t_max)
    ax_energy.set_ylabel("energy")
    ax_energy.set_xlabel("time")
    (pt_te,) = ax_energy.plot(
        time_axis, ke_hist + fe_hist, "k-", markersize=1, label="total"
    )
    (pt_ke,) = ax_energy.plot(
        time_axis, ke_hist, "b-", markersize=1, label="ke"
    )
    (pt_fe,) = ax_energy.plot(
        time_axis, fe_hist, "g-", markersize=1, label="fe"
    )
    plt.yscale("log")
    ax_energy.legend(
        [pt_ke, pt_fe, pt_te],
        [pt_ke.get_label(), pt_fe.get_label(), pt_te.get_label()],
        loc="upper right",
    )
    return ax_energy


def plot_energy_history(
    m: PicModel, plot_title="Time evolution of energy", hold=True
):
    """Generate log-log plot of the total kinetic and field energy history."""
    print("Generating plots of the total energy history.")
    fig = plt.figure(figsize=(12, 6))
    fig.suptitle(plot_title)
    ax_energy = fig.add_subplot(2, 1, (1, 2))
    _plot_energy_ax(m, ax_energy)
    plt.tight_layout()
    save_plot(
        f"energy_instability_growth_{datetime.datetime.now().strftime('%Y-%m-%d:%H:%M:%S')}.pdf"
    )
    if hold:
        plt.show()  # Waits for user to close the plots


def plot_initial_distribution(m: PicModel, hold=True):
    """Plot initial particle configuration using pyplot."""
    c = m.c
    print("Generating plots of initial particle state.")
    bin_width = 0.01

    fig1 = plt.figure(figsize=(12, 8))
    fig1.suptitle(f"Initial distribution (n={c.N})")
    # Get the un-normalized and normalized particle positions and velocities
    x_i_unorm = c.initial_x
    x_i = (x_i_unorm - c.x_min) / c.L
    v_i_unorm = c.initial_v
    # v_i = v_i_unorm / c.L
    x_j = c.x_j
    x_j_unorm = (c.x_j * c.L) + c.x_min

    # Plot initial weighted particle positions on the grid
    rho_weight_ngp = weight_particles(x_i, x_j, c.dx, c.M, order=0)
    print(f"Total charge (ngp): {np.sum(rho_weight_ngp * c.dx)}")
    rho_weight_lin = weight_particles(x_i, x_j, c.dx, c.M, order=1)
    print(f"Total charge (linear): {np.sum(rho_weight_lin * c.dx)}")
    ax_init_position = fig1.add_subplot(2, 2, 1)
    (pt_ngp,) = ax_init_position.step(
        x_j_unorm,
        rho_weight_ngp,
        color="r",
        marker="o",
        where="mid",
        linewidth=2,
        label="NGP",
        markersize=5,
    )
    (pt_linear,) = ax_init_position.plot(
        x_j_unorm,
        rho_weight_lin,
        color="g",
        marker="o",
        linestyle="--",
        linewidth=2,
        label="Linear",
        markersize=5,
    )
    ax_init_position.legend(
        [pt_ngp, pt_linear],
        [pt_ngp.get_label(), pt_linear.get_label()],
    )
    ax_init_position.set_ylim(bottom=0)
    ax_init_position.set_xlabel(r"$x$")
    ax_init_position.set_ylabel("Density")
    plt.xlim(c.x_range)
    plt.title("Position")

    # Plot initial velocity histogram
    ax_init_velocity = fig1.add_subplot(2, 2, 2)
    bins = math.ceil((c.v_range[1] - c.v_range[0]) / bin_width)
    ax_init_velocity.hist(v_i_unorm, bins=bins, range=c.v_range)
    ax_init_velocity.set_xlabel(r"$v$")
    plt.xlim(c.x_range)
    plt.title("Velocity")

    # Plot initial positions in phase space
    ax_init_phase = fig1.add_subplot(2, 2, (3, 4))
    plt.title("Initial phase space")
    n2 = math.ceil(c.N / 2)
    ax_init_phase.plot(
        x_i_unorm[:n2],
        v_i_unorm[:n2],
        ".",
        color="tab:orange",
        markersize=c.markersize,
        label="xv",
    )
    ax_init_phase.plot(
        x_i_unorm[n2:],
        v_i_unorm[n2:],
        ".",
        color="tab:cyan",
        markersize=c.markersize,
        label="xv",
    )
    plt.xlim(c.x_range)
    ax_init_phase.set_xlabel(r"$x$")
    ax_init_phase.set_ylabel(r"$v$")
    # Plot grid points
    if c.plot_grid_lines:
        for grid_pt in x_j_unorm:
            ax_init_phase.axvline(
                grid_pt,
                linestyle="--",
                color="k",
                linewidth=0.2,
            )
            ax_init_position.axvline(
                grid_pt,
                linestyle="--",
                color="k",
                linewidth=0.2,
            )
    plt.tight_layout()
    save_plot(f"initial_hist_{c.N}_particles.pdf")
    if hold:
        plt.show()  # Waits for user to close the plot


def plot_snapshots(m: PicModel, snapshot_times=None, hold=True):
    print("Generating snapshots of state at various time intervals.")
    c = m.c
    d = m.d
    if not m.has_run:
        m.run()
    t_max = c.t_max
    if not snapshot_times:
        snapshot_times = [0, 0.25 * t_max, 0.5 * t_max, 0.75 * t_max, t_max]
    dt = c.dt
    t_steps = c.t_steps
    N = c.N
    L = c.L
    x_min = c.x_min
    x_range = c.x_range
    subsample_ratio = c.subsample_ratio
    x_hist = d.x_hist
    v_hist = d.v_hist
    snapshot_times.sort()
    snapshot_frames = [math.floor(t / dt) for t in snapshot_times]
    snapshots = []
    for frame in range(t_steps):
        if frame in snapshot_frames:
            snapshots.append(
                {
                    "x": x_hist[:, int(frame / subsample_ratio)],
                    "v": v_hist[:, int(frame / subsample_ratio)],
                    "frame": frame,
                }
            )
    print(f"Sampled {len(snapshots)} snapshots over {t_steps} time steps.")
    fig = plt.figure()
    fig.suptitle(f"Time snapshots (n={N})")
    num_subplots = len(snapshots)
    idx = 1
    for snapshot in snapshots:
        ax_xv = fig.add_subplot(num_subplots, 1, idx)
        cur_t = snapshot["frame"] * dt
        ax_xv.set_ylabel("v")
        ax_xv.set_title(f"t={cur_t:.2f}")
        plt.plot(
            (snapshot["x"] * L) + x_min,
            (snapshot["v"] * L),
            "ko",
            markersize=1,
        )
        plt.xlim(x_range)
        if idx == num_subplots:
            ax_xv.set_xlabel("x")
        idx += 1
    plt.tight_layout()
    save_plot(f"snapshots_{N}_particles.pdf")
    if hold:
        plt.show()  # Waits for user to close the plots


def plot_traces(
    m: PicModel,
    max_traces: int = 30,
    hold: bool = True,
    start_at_frame: int = 0,
):
    """Generate trace plots of particles in phase space.

    Args:
        m: Initialized PicModel
        max_traces: Plot traces of up to this many particles.
        hold: If True, hold plots with plt.show()
        start_at_frame: Plot traces starting a this timestep.
    """
    c = m.c
    d = m.d
    if not m.has_run:
        m.run()
    N = c.N
    wp = c.wp
    dt = c.dt
    x_hist = d.x_hist
    v_hist = d.v_hist
    x_range = c.x_range
    L = c.L
    x_min = c.x_min
    fig = plt.figure(figsize=(12, 8))
    fig.suptitle(
        f"Particle Traces (n={N}, wp*dt={wp*dt:.3f}, 1st-order weighting)"
    )
    ax_xv = fig.add_subplot(211)
    for i in range(N)[::max_traces]:
        position = (x_hist[i, start_at_frame:] * L) + x_min
        velocity = v_hist[i, start_at_frame:] * L
        ax_xv.plot(position, velocity, ".", markersize=1)
        ax_xv.set_xlabel("x")
        ax_xv.set_ylabel("v")
        ax_xv.set_title("Particle Traces")
        ax_xv.set_xlim(x_range)
    ax_energy = fig.add_subplot(212)
    _plot_energy_ax(m, ax_energy)
    plt.tight_layout()
    save_plot(f"traces_{N}_particles.pdf")
    if hold:
        plt.show()  # Waits for user to close the plots


def _init_animation(x_range, v_min, v_max, ax_xv, pt_xv1, pt_xv2):
    ax_xv.set_xlim(x_range)
    ax_xv.set_ylim(v_min, v_max)
    return (pt_xv1, pt_xv2)


def _animate_frame(
    frame,
    x_hist,
    v_hist,
    ke_hist,
    fe_hist,
    x_min,
    L,
    time_axis,
    pt_ke,
    pt_fe,
    pt_te,
    pt_xv1,
    pt_xv2,
    time_text,
    subsample_ratio,
    dt,
):
    current_time = frame * dt * subsample_ratio
    time_text.set_text(f"t = {current_time:.2f}")
    N = x_hist.shape[0]
    n2 = math.ceil(N / 2)
    pt_xv1.set_data((x_hist[:n2, frame] * L) + x_min, (v_hist[:n2, frame] * L))
    if n2 > 0:
        pt_xv2.set_data(
            (x_hist[n2:, frame] * L) + x_min, (v_hist[n2:, frame] * L)
        )
    pt_ke.set_data(time_axis, ke_hist)
    pt_fe.set_data(time_axis, fe_hist)
    pt_te.set_data(time_axis, fe_hist + ke_hist)
    return (pt_xv1, pt_xv2, time_text, pt_ke, pt_fe, pt_te)


def animate_phase_space(
    m: PicModel,
    repeat: bool = False,
    plot_grid_lines: bool = True,
    hold: bool = True,
):
    c = m.c
    d = m.d
    if not m.has_run:
        m.run()
    N = c.N
    M = c.M
    t_max = c.t_max
    dt = c.dt
    x_range = c.x_range
    v_range = c.v_range
    markersize = c.markersize

    fig = plt.figure(figsize=(12, 8))
    fig.suptitle(f"n={N}  m={M}  dt={dt:.4f} t_max={t_max:.4f}")
    ax_xv = plt.subplot2grid((2, 2), (0, 0), colspan=2, rowspan=1)
    ax_energy = plt.subplot2grid((2, 2), (1, 0), colspan=2, rowspan=1)

    ax_xv.set_title("Phase space animation")
    ax_xv.set_ylabel("v")
    ax_xv.set_xlabel("x")
    ax_xv.set_xlim(x_range)
    ax_xv.set_ylim(v_range)

    ax_energy.set_title("Energy")
    ax_energy.set_xlim(0, t_max)
    ax_energy.set_ylim(0, 1.2 * np.max(d.fe_hist + d.ke_hist))
    ax_energy.set_ylabel("energy")
    ax_energy.set_xlabel("time")

    (pt_xv1,) = ax_xv.plot(
        [],
        [],
        ".",
        color="tab:orange",
        markersize=markersize,
        label="xv",
    )
    (pt_xv2,) = ax_xv.plot(
        [],
        [],
        ".",
        color="tab:cyan",
        markersize=markersize,
        label="xv",
    )
    (pt_ke,) = ax_energy.plot([], [], "b-", markersize=1, label="ke")
    (pt_fe,) = ax_energy.plot([], [], "g-", markersize=1, label="fe")
    (pt_te,) = ax_energy.plot([], [], "k-", markersize=1, label="total")
    # plt.yscale("log")
    ax_energy.legend(
        [pt_ke, pt_fe, pt_te],
        [pt_ke.get_label(), pt_fe.get_label(), pt_te.get_label()],
    )

    # Add a label to the frame showing the current time. Updated each time step
    # in update()
    time_text = ax_xv.text(0.02, 0.95, "", transform=ax_xv.transAxes)
    animate = partial(
        _animate_frame,
        x_hist=d.x_hist,
        v_hist=d.v_hist,
        ke_hist=d.ke_hist,
        fe_hist=d.fe_hist,
        x_min=c.x_min,
        L=c.L,
        time_axis=c.time_axis,
        pt_ke=pt_ke,
        pt_fe=pt_fe,
        pt_te=pt_te,
        pt_xv1=pt_xv1,
        pt_xv2=pt_xv2,
        time_text=time_text,
        subsample_ratio=c.subsample_ratio,
        dt=dt,
    )
    init_animation = partial(
        _init_animation,
        x_range=c.x_range,
        v_min=c.v_min,
        v_max=c.v_max,
        ax_xv=ax_xv,
        pt_xv1=pt_xv1,
        pt_xv2=pt_xv2,
    )
    # Evolve positions until t_max. Animate particle positions in phase space.
    animation = FuncAnimation(
        fig,
        animate,
        frames=range(d.x_hist.shape[1]),
        init_func=init_animation,
        blit=True,
        interval=1,
        repeat=repeat,
    )
    plt.tight_layout()
    if hold:
        plt.show()  # Waits for user to close the plot
    else:
        create_folder(os.path.join(os.getcwd(), "plots", "pic1"))
        animation_name = os.path.join(
            "plots",
            "pic1",
            f"animation_{datetime.datetime.now().strftime('%Y-%m-%d:%H:%M:%S')}.mp4",
        )
        animation.save(
            animation_name,
            progress_callback=lambda i, n: print(f"Saving frame {i} of {n}"),
        )


###############################################################################
# TODO: old animation code using FuncAnimation
# ###############################################################################
# def init_animation():
#     """Animation initialization."""
#     global ax_xv, pt_xv1, pt_xv2, x_range, v_min, v_max
#     ax_xv.set_xlim(x_range)
#     ax_xv.set_ylim(v_min, v_max)
#     return (pt_xv1, pt_xv2)


# def animate(frame):
#     """Call every time we update animation frame."""
#     global x_i, v_i, dt, ke_hist, L, x_min, x_max, t_steps
#     global pt_ke, pt_fe, pt_te, time_axis, pt_xv1, pt_xv2, time_text, ax_energy
#     global ke_hist, fe_hist, p_hist, x_hist, v_hist
#     global x_j, e_j, pt_efield, energy_max, efield_max, plot_energy, plot_fields
#     if frame == 0:
#         x_i, v_i, ke_hist = initialize()
#     x_i, v_i, e_j = time_step(
#         frame,
#         x_i=x_i,
#         v_i=v_i,
#         x_j=x_j,
#         ke_hist=ke_hist,
#         fe_hist=fe_hist,
#         p_hist=p_hist,
#         x_hist=x_hist,
#         v_hist=v_hist,
#         subsample_ratio=subsample_ratio,
#         nonumba=False,
#     )
#     if frame % subsample_ratio == 0:
#         current_time = frame * dt
#         time_text.set_text(f"t = {current_time:.2f}")
#         n2 = math.ceil(N / 2)
#         pt_xv1.set_data((x_i[:n2] * L) + x_min, (v_i[:n2] * L))
#         if n2 > 0:
#             pt_xv2.set_data((x_i[n2:] * L) + x_min, (v_i[n2:] * L))
#         if plot_fields:
#             if np.max(np.abs(e_j)) > 2 * efield_max:
#                 efield_max += np.max(np.abs(e_j))
#                 ax_efield.set_ylim(-efield_max * 2, efield_max * 2)
#             pt_efield.set_data(
#                 (np.concatenate([x_j, np.array([1.0])]) * L) + x_min,
#                 np.concatenate([e_j, e_j[0:1]]),
#             )
#         if plot_energy:
#             if fe_hist[frame] + ke_hist[frame] > 2 * energy_max:
#                 energy_max += fe_hist[frame] + ke_hist[frame]
#                 ax_energy.set_ylim(0, energy_max * 2)
#             pt_ke.set_data(time_axis, ke_hist)
#             pt_fe.set_data(time_axis, fe_hist)
#             pt_te.set_data(time_axis, fe_hist + ke_hist)
#     return pt_xv1, pt_xv2, time_text, pt_ke, pt_fe, pt_te, pt_efield

# def do_animation():
#     print("Generating animation of phase space over time.")
#     initialize()
#     bigfig = plt.figure(figsize=(12, 8))
#     bigfig.suptitle(f"n={N}  m={M}  dt={dt:.4f} t_max={t_max:.4f}")
#     ax_xv = plt.subplot2grid((2, 2), (0, 0), colspan=2, rowspan=1)
#     ax_energy = plt.subplot2grid((2, 2), (1, 0))
#     ax_efield = plt.subplot2grid((2, 2), (1, 1))

#     ax_xv.set_title("Phase space animation")
#     ax_xv.set_ylabel("v")
#     ax_xv.set_xlabel("x")
#     ax_xv.set_xlim(x_range)
#     ax_xv.set_ylim(v_range)

#     ax_energy.set_title("Energy")
#     ax_energy.set_xlim(0, t_max)
#     # ax_energy.set_ylim(0, 2 * (fe_hist[0] + ke_hist[0]))
#     ax_energy.set_ylabel("energy")
#     ax_energy.set_xlabel("time")

#     ax_efield.set_title("Fields")
#     ax_efield.set_xlim(x_range)
#     ax_efield.set_ylim(v_range)
#     ax_efield.set_ylabel("Electric field")
#     ax_efield.set_xlabel("x")

#     (pt_xv1,) = ax_xv.plot(
#         [],
#         [],
#         ".",
#         color="tab:orange",
#         markersize=markersize,
#         label="xv",
#     )
#     (pt_xv2,) = ax_xv.plot(
#         [],
#         [],
#         ".",
#         color="tab:cyan",
#         markersize=markersize,
#         label="xv",
#     )
#     (pt_ke,) = ax_energy.plot([], [], "b-", markersize=1, label="ke")
#     (pt_fe,) = ax_energy.plot([], [], "g-", markersize=1, label="fe")
#     (pt_te,) = ax_energy.plot([], [], "k-", markersize=1, label="total")
#     ax_energy.legend(
#         [pt_ke, pt_fe, pt_te],
#         [pt_ke.get_label(), pt_fe.get_label(), pt_te.get_label()],
#     )
#     (pt_efield,) = ax_efield.plot([], [], "c", label="efield")

#     # Add the grid points to the plot of the fields, but only if there aren't
#     # too many of them
#     if x_j.size < 80 and plot_grid_lines:
#         for grid_pt in x_j:
#             ax_efield.axvline(
#                 (grid_pt * L) + x_min,
#                 linestyle="--",
#                 color="k",
#                 linewidth=0.2,
#             )

#     # Add a label to the frame showing the current time. Updated each time step
#     # in update()
#     time_text = ax_xv.text(0.02, 0.95, "", transform=ax_xv.transAxes)

#     # Evolve positions until t_max. Animate particle positions in phase space.
#     animation = FuncAnimation(
#         bigfig,
#         animate,
#         frames=t_steps,
#         init_func=init_animation,
#         blit=True,
#         interval=1,
#         repeat=repeat_animation,
#     )
#     plt.tight_layout()
#     plt.show()  # Waits for user to close the plot
